<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>读EOPL3第二章(Data Abstraction)</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Nisen" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<p class="date">Published: 2016-01-04</p>
</div>
<div id="content">
<h1 class="title">读EOPL3第二章(Data Abstraction)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc32e072">1. 概述</a></li>
<li><a href="#org450dbdc">2. 通过交互接口(Interface)来表述数据</a>
<ul>
<li><a href="#orge3b4356">2.1. 举个具体的例子，我们想要描述“自然数”这个数据集，interface可以是：=zero=,=is-zero?=,=successor=,=predecessor=，如果用$&lceil; v &rceil;$来指代数据v的表现形式的话，interface的实现需要满足下面条件：</a></li>
</ul>
</li>
<li><a href="#org4d23379">3. 两种表述数据类型的方法</a>
<ul>
<li><a href="#orgf704e4a">3.1. 第一种表示：Data Structure Representation</a></li>
<li><a href="#orgaba2c9f">3.2. 第二种表示：Procedural Representation</a></li>
</ul>
</li>
<li><a href="#orgc202998">4. 递归数据的interfaces</a></li>
<li><a href="#org47eff0d">5. 抽象语义和它的表现形式（Abstract  Syntax and Its Representation）</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgc32e072" class="outline-2">
<h2 id="orgc32e072"><span class="section-number-2">1</span> 概述</h2>
<div class="outline-text-2" id="text-1">
<p>
第二章讲述了数据抽象（data
abstrction）的概念，通过将数据集分成interface（交互接口）和implementation（具体实现）来对数据进行抽象，这样的好处是可以是写的代码不依赖于数据集具体的实现。
</p>
</div>
</div>

<div id="outline-container-org450dbdc" class="outline-2">
<h2 id="org450dbdc"><span class="section-number-2">2</span> 通过交互接口(Interface)来表述数据</h2>
<div class="outline-text-2" id="text-2">
<p>
通过Data
Abstraction的方式，将数据的表示分成Interface和Implementation，这样的好处是当需要更换数据的实现方式时，只要改写对应interface的实现方式，而不需要改写采用这些Interface的代码（client
code），使得具体的client code不依赖于数据的表现形式
(representation-independent)。比如，当我们写程序来操作文件时采用的open,read,write,close等方法，这些方法可以看成是interface，我们具体写的代码通过操作这些interface来完成相应的操作，如果文件的实现形式更改了，我们只需改写这些相应的open,read,write,close而不用改写具体的client code
</p>
</div>
<div id="outline-container-orge3b4356" class="outline-3">
<h3 id="orge3b4356"><span class="section-number-3">2.1</span> 举个具体的例子，我们想要描述“自然数”这个数据集，interface可以是：=zero=,=is-zero?=,=successor=,=predecessor=，如果用$&lceil; v &rceil;$来指代数据v的表现形式的话，interface的实现需要满足下面条件：</h3>
<div class="outline-text-3" id="text-2-1">
\begin{align*}
(zero) &= \lceil 0 \rceil \\
(is-zero? \lceil n \rceil) &= 
\begin{cases}
\#t, & \text{n=0} \\
\#f, & \text{n $\neq$ 0}
\end{cases} \\
(successor \lceil n \rceil) &= \lceil n+1 \rceil (n\geq 0) \\
(predecessor \lceil n+1 \rceil) &= \lceil n \rceil (n\geq 0)
\end{align*}


<p>
这样当我们写程序的时候就可以使用这些interface来操作自然数集，比如定义加法：
</p>

<pre class="example">
(define plus
  (lambda (x y)
    (if (is-zero? x)
        y
        (successor (plus (predecessor x) y)))))
</pre>

<p>
不管interface的是怎么实现的，加法总是可以这样定义。其中用来构造数据类型的interface叫做constructors（上面例子中的｀zero｀，｀successor｀，｀predecessor｀），从数据值里提取信息的叫observers（上面例子中的｀is-zero?｀）。
而interface怎么实现取决于数据以怎样的方式表示：
</p>

<ol class="org-ol">
<li><p>
一元表示的方法（Unary representation） 一元表示法可以这么定义：
</p>

<p>
&lceil; 0 &rceil; = ()<br />
&lceil; n+1 &rceil; = (\#t \;.\; &lceil; n &rceil;)
</p>

<p>
在这种表示法下，上述自然数的interface可以这么定义：
</p>

<pre class="example">
(define zero (lambda () ’()))
(define is-zero? (lambda (n) (null? n)))
(define successor (lambda (n) (cons #t n)))
(define predecessor (lambda (n) (cdr n)))
</pre></li>

<li><p>
scheme　数字表示的方法（Scheme number representation）
scheme　数字表示的方法　是用shceme中的整数n代表\(\lceil n \rceil\)
在这种表示法下，上述自然数的interface可以这么定义：
</p>

<pre class="example">
(define zero (lambda () 0))
(define is-zero? (lambda (n) (zero? n)))
(define successor (lambda (n) (+ n 1)))
(define predecessor (lambda (n) (- n 1)))
</pre></li>

<li><p>
大数字表示法（Bignum representation） 
大数字表示法可以这么定义：
</p>

<p>
&lceil; n &rceil; = 
</p>
\begin{cases}
(), &\text{n = 0}\\
(r \;.\; \lceil q \rceil), &\text{n = qN + r, 0 $\leq$ r $\leq$ N}
\end{cases}
<p>
 按照这个定义，取N = 16， $&lceil; 33 &rceil;$　＝　(1 2),
&lceil; 258 &rceil; = （2 0 1），
因为\(258 = 2 \times 16^0 + 0 \times 16^1 + 1 \times 16^2\)
在这种表示法下，上述自然数的interface可以这么定义： 
</p></li>
</ol>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #4d4d4c;">(</span>define N 10<span style="color: #4d4d4c;">)</span>

<span style="color: #4d4d4c;">(</span>define zero <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">()</span> '<span style="color: #eab700;">()</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>

<span style="color: #4d4d4c;">(</span>define is-zero? 
  <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">(</span>n<span style="color: #eab700;">)</span> 
    <span style="color: #eab700;">(</span>null? n<span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>

<span style="color: #4d4d4c;">(</span>define successor 
  <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">(</span>n<span style="color: #eab700;">)</span> 
    <span style="color: #eab700;">(</span><span style="color: #718c00;">cond</span> <span style="color: #718c00;">(</span><span style="color: #4271ae;">(</span>null? n<span style="color: #4271ae;">)</span> '<span style="color: #4271ae;">(</span>1<span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span> 
    <span style="color: #718c00;">(</span><span style="color: #4271ae;">(</span>= <span style="color: #4d4d4c;">(</span>+ <span style="color: #3e999f;">(</span>car n<span style="color: #3e999f;">)</span> 1<span style="color: #4d4d4c;">)</span> N<span style="color: #4271ae;">)</span> <span style="color: #4271ae;">(</span>cons 0 <span style="color: #4d4d4c;">(</span>successor <span style="color: #3e999f;">(</span>cdr n<span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span> 
    <span style="color: #718c00;">(</span>else <span style="color: #4271ae;">(</span>cons <span style="color: #4d4d4c;">(</span>+ <span style="color: #3e999f;">(</span>car n<span style="color: #3e999f;">)</span> 1<span style="color: #4d4d4c;">)</span> <span style="color: #4d4d4c;">(</span>cdr n<span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span><span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>

<span style="color: #4d4d4c;">(</span>define predecessor 
  <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">(</span>n<span style="color: #eab700;">)</span> 
    <span style="color: #eab700;">(</span><span style="color: #718c00;">cond</span> <span style="color: #718c00;">(</span><span style="color: #4271ae;">(</span>null? n<span style="color: #4271ae;">)</span> <span style="color: #4271ae;">(</span>eopl:error'predecessor <span style="color: #3e999f;">"zero.~%"</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span> 
    <span style="color: #718c00;">(</span><span style="color: #4271ae;">(</span>zero? <span style="color: #4d4d4c;">(</span>car n<span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span> <span style="color: #4271ae;">(</span>cons <span style="color: #4d4d4c;">(</span>- N 1<span style="color: #4d4d4c;">)</span> <span style="color: #4d4d4c;">(</span>predecessor<span style="color: #3e999f;">(</span>cdr n<span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span> 
    <span style="color: #718c00;">(</span><span style="color: #4271ae;">(</span>and <span style="color: #4d4d4c;">(</span>= <span style="color: #3e999f;">(</span>car n<span style="color: #3e999f;">)</span> 1<span style="color: #4d4d4c;">)</span> <span style="color: #4d4d4c;">(</span>null? <span style="color: #3e999f;">(</span>cdr n<span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span> '<span style="color: #4271ae;">()</span><span style="color: #718c00;">)</span> 
    <span style="color: #718c00;">(</span>else <span style="color: #4271ae;">(</span>cons <span style="color: #4d4d4c;">(</span>- <span style="color: #3e999f;">(</span>carn<span style="color: #3e999f;">)</span> 1<span style="color: #4d4d4c;">)</span> <span style="color: #4d4d4c;">(</span>cdr n<span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span><span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4d23379" class="outline-2">
<h2 id="org4d23379"><span class="section-number-2">3</span> 两种表述数据类型的方法</h2>
<div class="outline-text-2" id="text-3">
<p>
通过数据类型：环境变量（environments）来说明，environments是是一个将变量和值绑定在一起的有限的数据集。环境变量可以以这样的形式表示\({(var_1,val_1),...,(var_n,val_n)}\).对应的interface需要满足以下条件：
</p>

\begin{align*}
(empty-env) &= \lceil \theta \rceil \\
(apply-env \lceil f \rceil var) &= f(var) \\
(entend-env var v \lceil f \rceil) &= \lceil g \rceil ,\\
&where \; g(var1) = 
\begin{cases}
v, & \text{if $\;var_1$ = var} \\
f(var_1), & \text{otherwise}
\end{cases}
\end{align*}

<p>
其中`empty-env`用来构造一个空的环境变量,`apply-env`用来获取环境变量中的值，`entend-env`用来扩充环境变量。
根据以上interface，一个环境变量可以如下构造：
</p>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #4d4d4c;">(</span>define e <span style="color: #3e999f;">(</span>extend-env 'd 6 <span style="color: #eab700;">(</span>extend-env 'y 8 <span style="color: #718c00;">(</span>extend-env 'x 7
<span style="color: #4271ae;">(</span>extend-env 'y 14 <span style="color: #4d4d4c;">(</span>empty-env<span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span><span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>
</pre>
</div>
</div>


<div id="outline-container-orgf704e4a" class="outline-3">
<h3 id="orgf704e4a"><span class="section-number-3">3.1</span> 第一种表示：Data Structure Representation</h3>
<div class="outline-text-3" id="text-3-1">
<p>
根据environment的结构特征：每个environment可以从一个空的environment开始，用`extend-env`构造数次得到，所以每个环境变量可采用下面的语法表示：
</p>

<p>
#+END<sub>EXAMPLE</sub> lisp
Env-exp :: = (empty-env)
    :: = (extend-env Identifier Scheme-value Env-exp)
</p>

<p>
#+END<sub>EXAMPLE</sub>
</p>

<p>
注意到这个表示和描述lists的语法是一样的，所以可以得到下面的实现（采用类似lists的实现）：
</p>

<div class="org-src-container">
<pre class="src src-lisp">Env = <span style="color: #4d4d4c;">(</span>empty-env<span style="color: #4d4d4c;">)</span> | (extend-env Var SchemeVal Env)
Var = Sym

empty-env : () &#8594; Env
(define empty-env
  (<span style="color: #718c00;">lambda</span> () (list &#8217;empty-env)))

extend-env : Var &#215; SchemeVal &#215; Env &#8594; Env
(define extend-env
  (<span style="color: #718c00;">lambda</span> (var val env)
    (list &#8217;extend-env var val env)))

apply-env : Env &#215; Var &#8594; SchemeVal
(define apply-env
  (<span style="color: #718c00;">lambda</span> (env search-var)
    (<span style="color: #718c00;">cond</span>
      ((eqv? (car env) &#8217;empty-env)
        (report-no-binding-found search-var))
      ((eqv? (car env) &#8217;extend-env)
       (<span style="color: #718c00;">let</span> ((saved-var (cadr env))
             (saved-val (caddr env))
            (saved-env (cadddr env)))
         (<span style="color: #718c00;">if</span> (eqv? search-var saved-var)
             saved-val
             (apply-env saved-env search-var))))
      (else
         (report-invalid-env env)))))

(define report-no-binding-found
  (<span style="color: #718c00;">lambda</span> (search-var)
    (eopl:error &#8217;apply-env "No binding for ~s" search-var)))

(define report-invalid-env
  (<span style="color: #718c00;">lambda</span> (env)
    (eopl:error &#8217;apply-env "Bad environment: ~s" env)))

</pre>
</div>
</div>
</div>



<div id="outline-container-orgaba2c9f" class="outline-3">
<h3 id="orgaba2c9f"><span class="section-number-3">3.2</span> 第二种表示：Procedural Representation</h3>
<div class="outline-text-3" id="text-3-2">
<p>
这种表示法将envrionment看成一个procedure, 给定一个var,得到一个val具体实现如下
</p>
<div class="org-src-container">
<pre class="src src-lisp">Env = Var &#8594; SchemeVal

empty-env : <span style="color: #4d4d4c;">()</span> &#8594; Env
<span style="color: #4d4d4c;">(</span>define empty-env
  <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">()</span>
    <span style="color: #eab700;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #718c00;">(</span>search-var<span style="color: #718c00;">)</span>
      <span style="color: #718c00;">(</span>report-no-binding-found search-var<span style="color: #718c00;">)</span><span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>


extend-env : Var &#215; SchemeVal &#215; Env &#8594; Env
<span style="color: #4d4d4c;">(</span>define extend-env
  <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">(</span>saved-var saved-val saved-env<span style="color: #eab700;">)</span>
    <span style="color: #eab700;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #718c00;">(</span>search-var<span style="color: #718c00;">)</span>
      <span style="color: #718c00;">(</span><span style="color: #718c00;">if</span> <span style="color: #4271ae;">(</span>eqv? search-var saved-var<span style="color: #4271ae;">)</span>
          saved-val
          <span style="color: #4271ae;">(</span>apply-env saved-env search-var<span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span><span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>


</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc202998" class="outline-2">
<h2 id="orgc202998"><span class="section-number-2">4</span> 递归数据的interfaces</h2>
<div class="outline-text-2" id="text-4">
<p>
接下来看看如何得到interfaces，以lambda-calculus数据类型为例。
lambda-calculus可以采用如下定义：
</p>
<div class="org-src-container">
<pre class="src src-lisp">Lc-exp <span style="color: #8959a8;">::</span> = Identifier
       <span style="color: #8959a8;">::</span> = <span style="color: #4d4d4c;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #3e999f;">(</span>Identifier<span style="color: #3e999f;">)</span> Lc-exp<span style="color: #4d4d4c;">)</span>
       <span style="color: #8959a8;">::</span> = <span style="color: #4d4d4c;">(</span>Lc-exp Lc-exp<span style="color: #4d4d4c;">)</span>

</pre>
</div>

<p>
Lc-exp :: = Identifier :: = (lambda (Identifier) Lc-exp) :: = (Lc-exp
Lc-exp)
</p>

<p>
lambda-calculus的定义是采用递归的形式定义的，为了定义递归类型数据的interfaces，可以按照下面规则：
</p>

<blockquote>
<p>
1.对每一个数据类型归纳一个constructor和predicate
2.对每一个传给constructor的参数归纳一个extractor
</p>
</blockquote>



<p>
如此，可创建lambda-calculus的以下的interfaces:
</p>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #8e908c; font-style: italic;">;</span><span style="color: #8e908c; font-style: italic;">The constructors are:</span>
var-exp      : Var &#8594; Lc-exp
lambda-exp   : Var &#215; Lc-exp &#8594; Lc-exp
app-exp      : Lc-exp &#215; Lc-exp &#8594; Lc-exp

<span style="color: #8e908c; font-style: italic;">;</span><span style="color: #8e908c; font-style: italic;">The predicates are:</span>
var-exp?     : Lc-exp &#8594; Bool
lambda-exp?  : Lc-exp &#8594; Bool
app-exp?     : Lc-exp &#8594; Bool

<span style="color: #8e908c; font-style: italic;">;</span><span style="color: #8e908c; font-style: italic;">The extractors are:</span>
var-exp-&gt;var           :  Lc-exp &#8594; Var 
lambda-exp-&gt;bound-var  :  Lc-exp &#8594; Var
lambda-exp-&gt;body       :  Lc-exp &#8594; Lc-exp
app-exp-&gt;rator         :  Lc-exp &#8594; Lc-exp
app-exp-&gt;rand          :  Lc-exp &#8594; Lc-exp
</pre>
</div>

<p>
然而，每次都这样创建interfaces会很枯燥，scheme里提供了一个自动构造和实现interfaces的工具，对于刚刚的interfaces可以如下创建：
</p>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #4d4d4c;">(</span><span style="color: #718c00;">define-datatype</span> lc-exp lc-exp?
    <span style="color: #3e999f;">(</span>var-exp
        <span style="color: #eab700;">(</span>var identifier?<span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span>
    <span style="color: #3e999f;">(</span>lambda-exp
        <span style="color: #eab700;">(</span>bound-var identifier?<span style="color: #eab700;">)</span>
        <span style="color: #eab700;">(</span>body lc-exp?<span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span>
    <span style="color: #3e999f;">(</span>app-exp
        <span style="color: #eab700;">(</span>rator lc-exp?<span style="color: #eab700;">)</span>
        <span style="color: #eab700;">(</span>rand lc-exp?<span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>

</pre>
</div>

<p>
`define-datatype`依照如下格式：
</p>

<p>
(define-datatype type-name type-predicate-name<br />
\;\;{ (variant-name { (field-name predicate) }<sup>*</sup>)}^+)
</p>


<p>
使用这个`define-datatype`定义的数据可以像下面这样使用：
</p>

<div class="org-src-container">
<pre class="src src-lisp">```
&#65307;&#21028;&#26029;lambda-calculus&#37324;&#26159;&#21542;&#23384;&#22312;&#26576;&#20010;symbol
occurs-free? : Sym &#215; LcExp &#8594; Bool
<span style="color: #4d4d4c;">(</span>define occurs-free?
    <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">(</span>search-var exp<span style="color: #eab700;">)</span>
        <span style="color: #eab700;">(</span>cases lc-exp exp
            <span style="color: #718c00;">(</span>var-exp <span style="color: #4271ae;">(</span>var<span style="color: #4271ae;">)</span> <span style="color: #4271ae;">(</span>eqv? var search-var<span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span>
            <span style="color: #718c00;">(</span>lambda-exp <span style="color: #4271ae;">(</span>bound-var body<span style="color: #4271ae;">)</span>
                <span style="color: #4271ae;">(</span>and
                    <span style="color: #4d4d4c;">(</span>not <span style="color: #3e999f;">(</span>eqv? search-var bound-var<span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>
                    <span style="color: #4d4d4c;">(</span>occurs-free? search-var body<span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span>
            <span style="color: #718c00;">(</span>app-exp <span style="color: #4271ae;">(</span>rator rand<span style="color: #4271ae;">)</span>
                <span style="color: #4271ae;">(</span>or
                    <span style="color: #4d4d4c;">(</span>occurs-free? search-var rator<span style="color: #4d4d4c;">)</span>
                    <span style="color: #4d4d4c;">(</span>occurs-free? search-var rand<span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span><span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>
```
</pre>
</div>

<p>
这里采用了 <code>cases</code> 来判断采用那种形式， <code>cases</code> 语法如下：
</p>
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #4d4d4c;">(</span>cases type-name expression
  { <span style="color: #3e999f;">(</span>variant-name <span style="color: #eab700;">(</span> { field-name }*<span style="color: #eab700;">)</span> consequent<span style="color: #3e999f;">)</span> }*
  <span style="color: #3e999f;">(</span>else default<span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>

</pre>
</div>

<p>
<code>define-datatype</code> 提供了定义递归数据类型的一种选择，但不是唯一的方式。有时候根据特定情况可以定义一个更有效的形式，代价是需要手动实现这些interface的程序。
</p>
</div>
</div>

<div id="outline-container-org47eff0d" class="outline-2">
<h2 id="org47eff0d"><span class="section-number-2">5</span> 抽象语义和它的表现形式（Abstract  Syntax and Its Representation）</h2>
<div class="outline-text-2" id="text-5">
<p>
语法一般规定了表达形式，通常是通过字符串和值来表示。这样的表现形式称为“具体的语义（concrete syntax）”或者“外部表现（external representation）”，比如lambda-calculus的定义：
</p>

<div class="org-src-container">
<pre class="src src-lisp">Lc-exp <span style="color: #8959a8;">::</span> = Identifier
       <span style="color: #8959a8;">::</span> = <span style="color: #4d4d4c;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #3e999f;">(</span>Identifier<span style="color: #3e999f;">)</span> Lc-exp<span style="color: #4d4d4c;">)</span>
       <span style="color: #8959a8;">::</span> = <span style="color: #4d4d4c;">(</span>Lc-exp Lc-exp<span style="color: #4d4d4c;">)</span>
</pre>
</div>

<p>
lambda-calculus 也可以采用另外一种外部表现：
</p>

<div class="org-src-container">
<pre class="src src-lisp">Lc-exp <span style="color: #8959a8;">::</span> = Identifier
       <span style="color: #8959a8;">::</span> = proc Identifier =&gt; Lc-exp
       <span style="color: #8959a8;">::</span> = Lc-exp<span style="color: #4d4d4c;">(</span>Lc-exp<span style="color: #4d4d4c;">)</span>
</pre>
</div>


<p>
这些“外部表现”是便于人类识别的，但对于计算机来说，更具有意义的是“抽象语义（Abstract  Syntax）”或者叫做“内部表现（interal representation）”，抽象语义去除了不包含实际信息的符号。像之前定义的=define-datatype=提供了一种方便的方法来定义这种内部表现。
对于表达式=(lambda (x) (f (f x)))=的abstract syntax可以用下图表示：
<img src="static/images/ast-example.png" alt="ast-example.png" />
</p>

<p>
将具体语义和抽象语义互相转化是非常有意义的。如果具体语义是字符串，这个转化的过程称为解析（parsing），借助于解析器（parser）。通常写一个parser是很复杂的，我们可以借助一个parser generator来生成一个parser。如果具体语义是以一串列表给定的，解析过程会简单许多。
</p>

<p>
比如，对于lambda-calculus，在scheme中，像前面说的用 <code>define-datatype</code> 来定义那样,shceme read routine自动解析字符串成=lists=和=symbols=，然后转化为abstract syntax　会容易很多，像下面这个程序这样：
</p>
<div class="org-src-container">
<pre class="src src-lisp">parse-expression : SchemeVal &#8594; LcExp
<span style="color: #4d4d4c;">(</span>define parse-expression
    <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">(</span>datum<span style="color: #eab700;">)</span>
        <span style="color: #eab700;">(</span><span style="color: #718c00;">cond</span>
            <span style="color: #718c00;">(</span><span style="color: #4271ae;">(</span>symbol? datum<span style="color: #4271ae;">)</span> <span style="color: #4271ae;">(</span>var-exp datum<span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span>
            <span style="color: #718c00;">(</span><span style="color: #4271ae;">(</span>pair? datum<span style="color: #4271ae;">)</span>
                <span style="color: #4271ae;">(</span><span style="color: #718c00;">if</span> <span style="color: #4d4d4c;">(</span>eqv? <span style="color: #3e999f;">(</span>car datum<span style="color: #3e999f;">)</span> &#8217;lambda<span style="color: #4d4d4c;">)</span>
                    <span style="color: #4d4d4c;">(</span>lambda-exp
                        <span style="color: #3e999f;">(</span>car <span style="color: #eab700;">(</span>cadr datum<span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span>
                        <span style="color: #3e999f;">(</span>parse-expression <span style="color: #eab700;">(</span>caddr datum<span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>
                    <span style="color: #4d4d4c;">(</span>app-exp
                        <span style="color: #3e999f;">(</span>parse-expression <span style="color: #eab700;">(</span>car datum<span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span>
                        <span style="color: #3e999f;">(</span>parse-expression <span style="color: #eab700;">(</span>cadr datum<span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span>
                <span style="color: #718c00;">(</span>else <span style="color: #4271ae;">(</span>report-invalid-concrete-syntax datum<span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span><span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>

</pre>
</div>



<p>
而将抽象语义转化成具体语义会直观很多，比如将lambda-calculus的抽象语义转化成列表形式的具体语义，可以用下面的程序：
</p>

<div class="org-src-container">
<pre class="src src-lisp">unparse-lc-exp : LcExp &#8594; SchemeVal
<span style="color: #4d4d4c;">(</span>define unparse-lc-exp
    <span style="color: #3e999f;">(</span><span style="color: #718c00;">lambda</span> <span style="color: #eab700;">(</span>exp<span style="color: #eab700;">)</span>
        <span style="color: #eab700;">(</span>cases lc-exp exp
            <span style="color: #718c00;">(</span>var-exp <span style="color: #4271ae;">(</span>var<span style="color: #4271ae;">)</span> var<span style="color: #718c00;">)</span>
            <span style="color: #718c00;">(</span>lambda-exp <span style="color: #4271ae;">(</span>bound-var body<span style="color: #4271ae;">)</span>
                <span style="color: #4271ae;">(</span>list &#8217;lambda <span style="color: #4d4d4c;">(</span>list bound-var<span style="color: #4d4d4c;">)</span>
                    <span style="color: #4d4d4c;">(</span>unparse-lc-exp body<span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span>
            <span style="color: #718c00;">(</span>app-exp <span style="color: #4271ae;">(</span>rator rand<span style="color: #4271ae;">)</span>
                <span style="color: #4271ae;">(</span>list
                    <span style="color: #4d4d4c;">(</span>unparse-lc-exp rator<span style="color: #4d4d4c;">)</span> <span style="color: #4d4d4c;">(</span>unparse-lc-exp rand<span style="color: #4d4d4c;">)</span><span style="color: #4271ae;">)</span><span style="color: #718c00;">)</span><span style="color: #eab700;">)</span><span style="color: #3e999f;">)</span><span style="color: #4d4d4c;">)</span>

</pre>
</div>




<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan style='display:none;' id='cnzz_stat_icon_1276090118'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D1276090118' type='text/javascript'%3E%3C/script%3E"));</script>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Nisen</p>
<p class="email">Email: <a href="mailto:imnisen@163.com">imnisen@163.com</a></p>
<p class="validation"></p>
</div>
</body>
</html>
